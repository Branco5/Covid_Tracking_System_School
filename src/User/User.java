package User;

import Code.*;
import Servers.*;
import Room.*;

import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.TimeUnit;

/**
 * Defines attributes and functions for each user
 */
public abstract class User {
    private int number;
    private State state;
    private Code currentID;
    private List<Code> codesEmitted;
    private Map<Code, Integer> codesReceived; //stores codes received with respective distance value
    private CodeGenerator cg;
    private Date stateChangeTimestamp;

    public User(int number){
        this.number = number;
        this.state = State.CONTINUOUS;
        codesEmitted= new ArrayList<>();
        codesReceived= new HashMap<>();
        cg = new CodeGenerator();
        currentID = null;
        stateChangeTimestamp = new Date();
    }

    /**
     * Returns formatted state change timestamp
     * @return
     */
    public String getStateChangeTimeString(){
        SimpleDateFormat formatter = new SimpleDateFormat("yyyy/MM/dd");
        return formatter.format(stateChangeTimestamp);
    }

    /**
     * Returns codes generated by this user
     * @return
     */
    public List<Code> getCodesEmitted() throws Exception {
        update();
        return codesEmitted;
    }

    /**
     * Changes state of user
     * @param state
     * @param hs
     * @throws Exception
     */
    public void setState(State state, HealthOrgServer hs) throws Exception {
        if(this.getState()==state){
            throw new Exception ("User already in given state");
        }
        this.state = state;
        stateChangeTimestamp = new Date();
        notifyInfection(hs);
    }

    /**
     * Adds codes generated by this user to infected list
     * @param hs
     */
    public void notifyInfection(HealthOrgServer hs) throws Exception {
        update();
        if(this.getState()==State.INFECTED){
            hs.addInfectedList(this);
        }
    }

    /**
     * Generates new code
     * @param p
     */
    public void generateID(Position p){
        currentID = cg.generateCode(p);
        codesEmitted.add(currentID);
    }

    /**
     * Returns most recently generated code
     * @return
     */
    public Code getCurrentID() {
        return currentID;
    }

    /**
     * Receives id of another user and puts in map with respective distance
     * @param s incoming user
     * @param room to compare positions
     * @throws Exception
     */
    public void receiveID(User s, Room room) throws Exception {
        if(s.getNumber()!=this.getNumber()){

            Position receiverPosition = this.currentID.getPosition();
            Position senderPosition = s.getCurrentID().getPosition();

            int distance = room.comparePositions(receiverPosition, senderPosition);

            codesReceived.put(s.getCurrentID(), distance);
        }
    }

    /**
     * Executes receiveID for list of users
     * @param users
     * @param room
     * @throws Exception
     */
    public void receiveIDs(Set<User> users, Room room) throws Exception {
        for (User s : users) {
            this.receiveID(s, room);
        }
    }

    /**
     * Returns list of codes received that match list of codes of infected users in last 7 days
     * @param server HealthOrg
     * @return list of codes
     */
    public List<Code> verifyMatches(HealthOrgServer server) throws Exception {
        this.update();
        List<Code> matches = new ArrayList<>();

        for (Code c: server.getInfectedList()) {
            if(this.codesReceived.containsKey(c)){
                matches.add(c);
            }
        }

        return matches;
    }

    /**
     * Changes user state to ISOLATION
     * @param hs
     * @throws Exception if state change fails
     */
    public void enterIsolation(HealthOrgServer hs) throws Exception {
        if(getState()==State.INFECTED) throw new Exception("User already declared INFECTED, isolation mandatory!");
        this.setState(State.ISOLATION, hs);
        stateChangeTimestamp = new Date();
    }

    /**
     * Returns a String bases
     * @param server
     * @return
     */
    public String getHealthAdvice(HealthOrgServer server) throws Exception {
        update();
        int min = getMinDistanceToInfected(server);

        if(this.getState()==State.INFECTED){
            return "Você está infetado, deverá permanecer em isolamento";
        }

        if(min <= 2){
            return "Período de 15 dias de isolamento recomendado";
        }

        else if(min<=4){
            return "Vigiar sintomas";
        }

        else{
            return "Medidas extraordinárias não necessárias";
        }
    }

    /**
     * Gets minimum distance between user and infected user(s) in the last 7 days
     * @param server
     * @return
     */
    public int getMinDistanceToInfected(HealthOrgServer server) throws Exception {
        int min = 100;
        int current = 0;

        List<Code> matches = verifyMatches(server);

        for (Code c : matches) {
            current = this.codesReceived.get(c);
            if(current<min){
                min = current;
            }
        }

        return min;
    }

    /**
     * Removes codes older than 28 days and verifies state
     */
    public void update() throws Exception {
        removeOutDatedCodes();
    }

    /**
     * Sets state to continuous if state is isolated with timestamp greater than 15 days
     */
    public void verifyIsolation() throws Exception {
        if(this.state == State.CONTINUOUS){
            throw new Exception("User not in isolation");
        }
        if(this.state == State.INFECTED){
            throw new Exception("User infected, must remain in isolation");
        }
        if(getDifferenceDays(this.stateChangeTimestamp, new Date())<15) {
            throw new Exception("Must be in isolation for "+(
                    15 - (getDifferenceDays(new Date(),this.stateChangeTimestamp))
                    + " more days"));
        }
        this.state = State.CONTINUOUS;
        System.out.println("State changed to ISOLATED");
    }

    /**
     * Removes codes older than 28 days
     */
    public void removeOutDatedCodes(){
        codesEmitted.removeIf(code -> getDifferenceDays(code.getDate(), new Date()) >= 28);

        for (Code code : codesReceived.keySet()) {
            if(getDifferenceDays(code.getDate(), new Date()) > 28){
                codesReceived.remove(code);
            }
        }
    }

    /**
     * Gets difference between 2 dates in days
     * @param d1
     * @param d2
     * @return
     */
    public long getDifferenceDays(Date d1, Date d2) {
        long diff = d2.getTime() - d1.getTime();
        return TimeUnit.DAYS.convert(diff, TimeUnit.MILLISECONDS);
    }

    /**
     * Returns true if student is not in CONTINUOUS state
     * @return
     */
    public boolean isIsolated(){
        if(this.getState()==State.CONTINUOUS){
            return false;
        }
        return true;
    }

    /**
     * Returns user state
     * @return state
     */
    public State getState(){
        return state;
    }

    /**
     * Return user number
     * @return
     */
    public int getNumber() {
        return number;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) return false;

        if (!(obj instanceof User))
            return false;

        User u = (User) obj;

        return this.number == u.getNumber();

    }
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + number;
        return result;
    }
}
